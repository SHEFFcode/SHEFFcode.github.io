---
layout: post
title: HTTP
description: Let's explore what HTTP is.
date: 2025-08-15 15:01:35 +0300
image: '/images/HTTP_logo.png'
image_caption: 'Basics of internet communication [wikipedia.org](https://en.m.wikipedia.org/wiki/File:HTTP_logo.svg)'
tags: [Technologies]
---

HTTP protocol is the backbone of the internet. It has been developed in the early 90s, and has remained largely static until 2015. Let's dig into its various iterations and try to understand what it is, how it works and how it has recently changed.

## Primer on Internet communication

Before we look at what HTTP is, I want to give a bit of a primer on how the internet works.  Genreally there are 2 models of internet communication:
- 7 Layer OSI model
- 4 Layer TCP/IP model

If you have read my article on ARPANET, you are probably familiar with the TCP/IP model and it's history, so I will not bore you with it here, but here is the breakdown chart below:

![OSI Model](/images/OSIModel.png)

Here we care about the transport and application layers of the TCP/IP model, namely HTTP and TCP / UDP.

- TCP stands for Transmission Control Protocol, and it uses a three way handshake to establish a connection, has retransmission protocols to recover lost packets.
- UDP standards for User Datagram Protocol. UDP does not set up a connection, and does not have any retransmission mechanisms. It simply sends data out and hopes it makes it in. This makes it useful for video games and viop calls. There is also no guaranteed oder in UDP transmissions.
- HTTP stands for hypertext transfer protocol. It traditionally relies on TCP for transport, adding things like headers, body, verbs and response codes as a structure of the request.


## HTTP

It might surpise some folks to know, but we are all still mostly using HTTP version 1. Considering HTTP protocol came out in 1991 (with version 0.9), that might seem like a really slow pace of progress. But really it's a testament to how good the original technology was.

Here is a listing of version histories:
- 0.9 in 1991 - basic protocol 1 TPC connection for every request
- 1.0 in 1996 - public version, largely same as 0.9
- 1.1 in 1997 - allowed for keepalive header to re-use a single connection for many requests
- 2.0 in 2015 - headers allowed to be compressed, bidirectional streams, server side push
- 3.0 in 2022 - Use QUICK + UDP instead of TPC for tranmission protocol

The original protocol itself is fairly simple, relying on request-response cycles between the client and the host.  The communication takes place via the TCP/IP protocol.  It includes the following information:
- URL
- HTTP Method (verb)
- Headers
- Request Body

### Sample Requests

Here is a sample HTTP GET request (via version 1.1, still one of the most widely used HTTP versions):

```
GET /watch?v=8PoQpnlBXD0 HTTP/1.1
Host: www.youtube.com
Cookie: GPS=1; VISITOR_INFO1_LIVE=kOe2UTUyPmw; YSC=Jt6s9YVWMd4
```

Here is a HTTP Get request (version 1.1) via [freecodecamp](https://www.freecodecamp.org/news/what-is-http/).
```
POST /v1/images/upload HTTP/1.1
Host: api.thecatapi.com
x-api-key: API_KEY
Content-Length: 232
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW

------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="file"; filename="/C:/Users/USER/Downloads/cat1.jpg"
Content-Type: image/jpeg

(data)
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

HTTP URL subsections (https://www.freecodecamp.org/news/content/images/2023/04/url.jpg):

![URL Subsections](/images/URLSubsections.jpg)

Http verbs:
- HEAD - status of resource, rarely used
- GET - Read method of CRUD
- POST - Create method of CRUD
- PUT - Update method of CRUD
- DELETE - Delete method of CRUD

### Sample Responses

HTTP Responses:

```
HTTP/1.1 200 OK
Date: Sun, 28 Mar 2023 10:15:00 GMT
Content-Type: application/json
Server: Apache/2.4.39 (Unix) OpenSSL/1.1.1c PHP/7.3.6
Content-Length: 1024

{
    "name": "John Doe",
    "email": "johndoe@example.com",
    "age": 30,
    "address": {
        "street": "123 Main St",
        "city": "Anytown",
        "state": "CA",
        "zip": "12345"
    }
}
```

Http Response Codes:
- 100 - continue (rare)
- 200 - ok, request succeded, usually result of successful get request
- 201 - created, usually result of successful post request
- 202 - accepted, ussually a result of successful put request
- 404 - not found
- 500 - internal server error
- 301 - permanent redirect

### HTTP 1 request Response Structure
HTTP 1 uses 1 request per resource. It opens up a connection to the server (which can be kept alive if appropriate header is provided), and then uses that TCP connection to obtain the resource in question. In traditional HTTP this is done one request / response at a time, and browsers have a 6 connection per domain limit (aside from IE that I will describe in the HTTP2 section below). 

This means that a single connection will need to wait until the full resource has been transferred before requesting the next resource on the same connection. This is pretty much synchronous communication that we have been moving away from in Computer Science in the last few years. The plus side of this style of communication though is that it's simple, and it's reliable. TCP ensures that packets make it, and a connection focuses on just one resource at a time.

There was however an effort to improve this structure in cases where we know we will need multiple resources. This is called a pipelined connection. In a pipelined connection, you request multiple resources in order, and use the same request to communicate this intent to the server, and the server then sends you the resources back in order on the same response trip.  Here is a helpful graphic below:

![HTTP with piepelining](/images/HTTPpipelining.png)
[source](https://en.wikipedia.org/wiki/HTTP_pipelining)

As a side note, there is a related concept of [pipelining](https://redis.io/docs/latest/develop/use/pipelining/) in redis, which serves a similar need and returns in a similar way (result of commands in order). But that is for another article.

### Support for HTTP 1
Support for HTTP 1 is widespread as it has been the default standard for over 16 years before arrival of viable alternatives. Any language worth its salt can communicate via http 1.


## HTTP 2
Here is some introductory info on HTTP2:

![HTTP2](/images/HTTP2.png)

Here is another helpful slide:

![HTTP2 in one slide](/images/http21Slide.png)

We maintain a single TCP connection, which contains multiple prioritized streams called multiplexing.  While multiplexing might sound like a complicated term, it just means serving multiple requests on a single connection. Let's explore how we can service requests in the current HTTP protocol:

1. One connection per resource (standard HTTP 1.1 model). The browser can usually have about 6 connections open (aside from IE 10 which has 8, and IE 11 which has 13) per domain. This means there is a hard limit of simultaneous resources that a browser can obtain. 
   1. If we talk about the world of microservices, there is no hard limit on connections, but having one connection per resource can very quickly overwhelm the server, creating a DDoS like environment, which is why there are hard limits on the browser.
2. One Pipelined connection per resource, this is available in HTTP1.1, and allows you to ask for multiple resources on a single TCP connection. The issue with pipelining is that first all request commands must go out and then all responses must come back in the same order, which slows down the server in case one of the resources is really large or is temporarily unavailable.
3. One Multiplexed connection per resource. This means having multiple independent bidirectional streams per connection. This means that resource request and responses can come back in any order, leaving it up to the user to use them right away or wait for a dependency. This creates a lot of flexibility both in the world of web browsers (that often depend on CSS, Fonts, Images etc), but especially so in the world of microservices that are constantly chatting to each other and requesting various resources.

Here is a helpful graphic:

![Http Varieties](/images/HttpVarieties.jpeg)


And an even more helpful gif from [Free Manning Content](https://freecontent.manning.com/animation-http-1-1-vs-http-2-vs-http-2-with-push/)

![HTTP Connection Types](/images/HTTP-vs-with-Push-HTTP1.gif)
![HTTP Connection Types](/images/HTTP-vs-with-Push-HTTP2.gif)
![HTTP Connection Types](/images/HTTP-vs-with-Push-HTTP2push.gif)

### Support for HTTP2
Currently in the world that I operate in (Python, Ruby, JS and Kotlin), support for HTTP 2 is as follows:

* Python
  * gUnicorn has no support for HTTP2, but there are ASGI servers that do, namely Daphne and Hypercorn. I will hopefully write an article about this soon.
  * [Httpx](https://scrapfly.io/blog/web-scraping-with-python-httpx/#using-httpx) client supports http2, while requests client does not
* Ruby (rails) 
  * Rails does not currently support HTTP2 via puma (aside from making it available via nginx with limited benefits)
  * There is some early support for it in the falcon server [here](https://socketry.github.io/falcon/)
  * Faraday does have support for http 2 via nethttp2 [adapter](https://github.com/andrehjr/faraday-net-http2)
* NodeJS
  * Node supports http2 out of the box, see a decent guide for it [here](https://www.sohamkamani.com/nodejs/http2/)
* Kotlin
  * Kotlin will support HTTP2 via Netty and Jetty servers see ktor [documentation](https://ktor.io/docs/server-http2.html)
  * Spring boot ships with Tomcat 10 which supports http2 as well, see more info [here](https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support)
  * [OKHttp](https://square.github.io/okhttp/) client support HTTP2, as does java's http client


## Http 3
Where HTTP 2 focused on improving the existing structure of HTTP communication via a multiplexed connection and compression, HTTP3 looks to refactor the underlying transmission protocol.  To this end, it moves away from TCP/IP, and moves into QUIC and UDP. This new transmission protocol allows for speeds up to 4x faster than HTTP 1.1. ([Source](https://requestmetrics.com/web-performance/http3-is-fast/))

Why would you want to introduce a new protocol and move away from TCP? The answer is transport layer head of line blocking. Essentially the HTTP2 protocol removes the application layer head of line blocking by allowing for multiple concurrent bidirectional logical streams on a single TCP connection.  However, the TCP protocol itself maintains it's head of line blocking by design, as it waits for a lost packet to be recovered before allowing the whole connection to continue.

Here is a helpful graphic from [wikipedia](https://en.wikipedia.org/wiki/Head-of-line_blocking):

![HOLBlocking](/images/HOLBlocking.png)

So where HTTP 2 addressed head of line blocking on application layer (where specific packets could not be given back to the port for transmission before others were complete), HTTP 3 addresses it in the transport layer by switching away from TCP to a new standard called QUIC (quick udp internet connections).

### Setting up HTTP 3 connection
In order to give your client an option to transition your connection to HTTP3, you can include the following header:

```
Alt-Svc: h3=":50781"
```

Which tells your client that you can do HTTP3 connection via UDP on port `50781`, and transfers the connection from TCP to UDP transport protocol.

### How can we use UDP?
But hold on, doesn't UDP not have any safety mechanisms to re-transmit lost packets? Does this mean that my data can become corrupted now? Well not really. QUICK solves the UDP lossiness by moving the retransmission logic up to the application layer. This comes with some plusses and minuses. 

- The plus is that the re-transmission algorithms and implementations can be iterated on very quickly, instead of having to wait for progress at the system kernel level. 
- The downside is that there is currently no hardware acceleration for this mechanism, meaning that all the work for doing this lies on the CPU. Google and facebook report that QUIC based connections require 2x the CPU capacity compared to HTTP2 over TCP. [Source](https://http3-explained.haxx.se/en/proc/proc-status#kernels-and-cpu-load)
  - Since QUIC still relies on TCP-like acknowledgements of packet receipt [See here](https://datatracker.ietf.org/doc/html/rfc6582) and [here](https://datatracker.ietf.org/doc/html/draft-ietf-quic-recovery-12#section-4), the speed of transmission on each channel might still be slower than if it used Forward error correction [See this video for more info](https://www.youtube.com/watch?v=Q5kVuM7zEUI)
- Another downside is that UDP connections are heavily monitored, and sometimes disabled or throttled in many organizations, because they have been used for video games or video streaming, which some institutions like schools or governments want to prevent. Those connections will then have to fall back to TCP and HTTP 2.


### Handshakes on QUIC
Thanks to the new QUIC protocol, there are some improvements to the handshake speed as well, as you no longer need a TCP handshake to establish a connection. For example, if you are connecting to a known host, a connection id can be re-used and you have have 0 RTT (0 round trip time) between the client and host to re-establish a connection. In fact this technique is used by HTTP3 to speed up network connection switchover (say you go from wifi to cellphone).

Here is the handshake illustration for greater clarity:

![TCP Handshake](/images/TCPvsQUIC.png)
[source](https://blog.workinghardinit.work/2021/06/30/microsoft-and-quic/)

### Support for HTTP 3
The standard is a bit new and there is not a lot of clients that support it. From what I have been able to find:

* Python
  * Has a supporting client called [aioquic](https://github.com/aiortc/aioquic)
  * Hypercorn has support for http3 via h3 [extra](https://pgjones.dev/blog/http-1-2-3-2019/)
* Ruby
  * Can't find much aside from some discussions on RACK [forums](https://github.com/rack/rack/discussions/2039)
* JS
  * Node has a ticket to support HTTP 3[source](https://github.com/nodejs/node/issues/38478), and there is a way to launch the server with `--experimental-http3` flag, but it's not production ready.
* Kotlin
  * OK Http does have some support planned, but not high priority [source](https://square.github.io/okhttp/5.x/okhttp/okhttp3/-protocol/-h-t-t-p_3/index.html)

## Sources
* https://medium.com/codavel-blog/quic-vs-tcp-tls-and-why-quic-is-not-the-next-big-thing-d4ef59143efd
* https://http3-explained.haxx.se/en/the-protocol/feature-handshakes
* https://en.wikipedia.org/wiki/QUIC
* https://www.rfc-editor.org/rfc/rfc9000.html
* https://requestmetrics.com/web-performance/http3-is-fast/
* https://en.wikipedia.org/wiki/HTTP_pipelining





